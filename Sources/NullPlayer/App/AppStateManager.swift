import AppKit

/// Manages saving and restoring the complete application state.
/// When "Remember State On Quit" is enabled (context menu toggle), saves app state
/// on quit and restores on launch.
///
/// ## Saved State (AppState struct, v2)
/// - **Window visibility**: playlist, EQ, browser, ProjectM, spectrum
/// - **Window frames**: main, playlist, EQ, browser, ProjectM, spectrum; ProjectM fullscreen
/// - **Audio**: volume, balance, shuffle, repeat, gapless, normalization
/// - **Sweet Fades**: enabled, duration
/// - **EQ**: enabled, auto, preamp, 10 bands
/// - **Playlist**: all tracks (local, Plex, Subsonic, Jellyfin, radio) with metadata
/// - **Playback position**: current track index, position in seconds
/// - **UI**: timeDisplayMode, isAlwaysOnTop, double size mode (modern UI)
/// - **Skin**: classic custom skin path, modern skin name
/// - **ProjectM**: preset index, fullscreen state
/// - **Audio output**: selected device UID
/// - **Browser**: browse mode (artists/albums/tracks/etc.)
/// - **UI mode**: which mode (modern/classic) the state was saved in
///
/// ## Restoration Flow
/// 1. `restoreSettingsState()` - called early in launch (skin, volume, EQ, windows, v2 fields)
/// 2. `restorePlaylistState()` - called after app is ready (tracks, current position)
///
/// Streaming tracks (Plex/Subsonic/Jellyfin) are initially loaded as placeholders with
/// saved metadata (title/artist/album/duration), then replaced asynchronously when the
/// real tracks are fetched from their servers.
///
/// When the UI mode changes between save and restore (e.g. modern -> classic), window
/// frames are NOT restored (they have incompatible sizes). Audio, playlist, and non-frame
/// settings are still restored normally.
///
/// ## Independent UserDefaults (persist regardless of Remember State)
/// Visualization modes, browser columns, radio stations, hide title bars, server credentials,
/// and other preferences are saved to UserDefaults on every change and are NOT part of AppState.
class AppStateManager {
    
    // MARK: - Singleton
    
    static let shared = AppStateManager()
    
    // MARK: - UserDefaults Keys
    
    private enum Keys {
        static let rememberStateEnabled = "rememberStateEnabled"
        static let savedAppState = "savedAppState"
    }
    
    // MARK: - State Structure
    
    /// Represents a saved track that can be restored
    struct SavedTrack: Codable, Equatable {
        // For local files
        var localURL: String?
        
        // For Plex tracks
        var plexRatingKey: String?
        var plexServerId: String?
        
        // For Subsonic tracks
        var subsonicId: String?
        var subsonicServerId: String?
        
        // For Jellyfin tracks
        var jellyfinId: String?
        var jellyfinServerId: String?
        
        // For radio tracks (internet radio streams)
        var radioURL: String?
        var radioStationName: String?
        
        // Display metadata (shown while loading streaming tracks)
        var title: String
        var artist: String?
        var album: String?
        var duration: Double?
        
        // MIME content type hint for casting (e.g. "audio/flac")
        // Preserves content type across restarts so Sonos casting doesn't default to audio/mpeg
        var contentType: String?
        
        /// Create from a Track
        static func from(_ track: Track, plexServerId: String?) -> SavedTrack {
            if track.url.isFileURL {
                return SavedTrack(
                    localURL: track.url.absoluteString,
                    title: track.title,
                    artist: track.artist,
                    album: track.album,
                    duration: track.duration
                )
            } else if let plexKey = track.plexRatingKey {
                return SavedTrack(
                    plexRatingKey: plexKey,
                    plexServerId: plexServerId,
                    title: track.title,
                    artist: track.artist,
                    album: track.album,
                    duration: track.duration
                )
            } else if let subId = track.subsonicId {
                return SavedTrack(
                    subsonicId: subId,
                    subsonicServerId: track.subsonicServerId,
                    title: track.title,
                    artist: track.artist,
                    album: track.album,
                    duration: track.duration,
                    contentType: track.contentType
                )
            } else if let jfId = track.jellyfinId {
                return SavedTrack(
                    jellyfinId: jfId,
                    jellyfinServerId: track.jellyfinServerId,
                    title: track.title,
                    artist: track.artist,
                    album: track.album,
                    duration: track.duration,
                    contentType: track.contentType
                )
            } else if !track.url.isFileURL {
                // Non-file URL without streaming service IDs = radio/internet stream
                // Match against known radio stations for station name
                let stationName = RadioManager.shared.stations.first(where: { $0.url == track.url })?.name
                return SavedTrack(
                    radioURL: track.url.absoluteString,
                    radioStationName: stationName ?? track.title,
                    title: track.title,
                    artist: track.artist,
                    album: track.album,
                    duration: track.duration
                )
            } else {
                // Unknown source - save as local URL fallback
                return SavedTrack(
                    localURL: track.url.absoluteString,
                    title: track.title,
                    artist: track.artist,
                    album: track.album,
                    duration: track.duration
                )
            }
        }
        
        /// Whether this is a local file
        var isLocal: Bool { localURL != nil }
        
        /// Whether this is a Plex track
        var isPlex: Bool { plexRatingKey != nil }
        
        /// Whether this is a Subsonic track
        var isSubsonic: Bool { subsonicId != nil }
        
        /// Whether this is a Jellyfin track
        var isJellyfin: Bool { jellyfinId != nil }
        
        /// Whether this is a radio/internet stream track
        var isRadio: Bool { radioURL != nil }
    }
    
    /// Complete application state that can be saved/restored
    struct AppState: Codable {
        // Window visibility
        var isPlaylistVisible: Bool
        var isEqualizerVisible: Bool
        var isPlexBrowserVisible: Bool
        var isProjectMVisible: Bool
        var isSpectrumVisible: Bool = false
        
        // Window frames (as strings for NSRect compatibility)
        var mainWindowFrame: String?
        var playlistWindowFrame: String?
        var equalizerWindowFrame: String?
        var plexBrowserWindowFrame: String?
        var projectMWindowFrame: String?
        var spectrumWindowFrame: String?
        var isProjectMFullscreen: Bool = false
        
        // Audio settings
        var volume: Float
        var balance: Float
        var shuffleEnabled: Bool
        var repeatEnabled: Bool
        var gaplessPlaybackEnabled: Bool
        var volumeNormalizationEnabled: Bool
        
        // Sweet Fades (crossfade) settings
        // Default values ensure backward compatibility with saved states from older versions
        var sweetFadeEnabled: Bool = false
        var sweetFadeDuration: Double = 5.0
        
        // EQ settings
        var eqEnabled: Bool
        var eqAutoEnabled: Bool = false
        var eqPreamp: Float
        var eqBands: [Float]
        
        // Playback state
        var playlistTracks: [SavedTrack]  // All tracks including streaming
        var playlistURLs: [String]?  // Legacy - for backward compatibility reading old saved states
        var currentTrackIndex: Int
        var playbackPosition: Double  // Position in seconds
        var wasPlaying: Bool
        
        // UI preferences
        var timeDisplayMode: String
        var isAlwaysOnTop: Bool
        
        // Skin
        var customSkinPath: String?
        
        // ProjectM preset
        var projectMPresetIndex: Int?
        
        // -- v2 fields (added for comprehensive state restoration) --
        
        // Double size mode (modern UI only)
        var isDoubleSize: Bool = false
        
        // Modern skin name
        var modernSkinName: String?
        
        // Audio output device
        var selectedOutputDeviceUID: String?
        
        // Library browser state
        var browserBrowseMode: Int?  // Raw value of PlexBrowseMode / ModernBrowseMode
        
        // UI mode the state was saved in (used to skip frame restoration on mode mismatch)
        var savedInModernMode: Bool = false
        
        // Version for future compatibility
        var stateVersion: Int = 2
        
        // MARK: - Custom Decoding for Backward Compatibility
        
        enum CodingKeys: String, CodingKey {
            case isPlaylistVisible, isEqualizerVisible, isPlexBrowserVisible, isProjectMVisible, isSpectrumVisible
            case mainWindowFrame, playlistWindowFrame, equalizerWindowFrame, plexBrowserWindowFrame, projectMWindowFrame, spectrumWindowFrame, isProjectMFullscreen
            case volume, balance, shuffleEnabled, repeatEnabled, gaplessPlaybackEnabled, volumeNormalizationEnabled
            case sweetFadeEnabled, sweetFadeDuration
            case eqEnabled, eqAutoEnabled, eqPreamp, eqBands
            case playlistTracks, playlistURLs, currentTrackIndex, playbackPosition, wasPlaying
            case timeDisplayMode, isAlwaysOnTop
            case customSkinPath
            case projectMPresetIndex
            // v2 fields
            case isDoubleSize, modernSkinName, selectedOutputDeviceUID
            case browserBrowseMode, savedInModernMode
            case stateVersion
        }
        
        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            
            // Window visibility
            isPlaylistVisible = try container.decode(Bool.self, forKey: .isPlaylistVisible)
            isEqualizerVisible = try container.decode(Bool.self, forKey: .isEqualizerVisible)
            isPlexBrowserVisible = try container.decode(Bool.self, forKey: .isPlexBrowserVisible)
            isProjectMVisible = try container.decode(Bool.self, forKey: .isProjectMVisible)
            isSpectrumVisible = try container.decodeIfPresent(Bool.self, forKey: .isSpectrumVisible) ?? false
            
            // Window frames
            mainWindowFrame = try container.decodeIfPresent(String.self, forKey: .mainWindowFrame)
            playlistWindowFrame = try container.decodeIfPresent(String.self, forKey: .playlistWindowFrame)
            equalizerWindowFrame = try container.decodeIfPresent(String.self, forKey: .equalizerWindowFrame)
            plexBrowserWindowFrame = try container.decodeIfPresent(String.self, forKey: .plexBrowserWindowFrame)
            projectMWindowFrame = try container.decodeIfPresent(String.self, forKey: .projectMWindowFrame)
            spectrumWindowFrame = try container.decodeIfPresent(String.self, forKey: .spectrumWindowFrame)
            isProjectMFullscreen = try container.decodeIfPresent(Bool.self, forKey: .isProjectMFullscreen) ?? false
            
            // Audio settings
            volume = try container.decode(Float.self, forKey: .volume)
            balance = try container.decode(Float.self, forKey: .balance)
            shuffleEnabled = try container.decode(Bool.self, forKey: .shuffleEnabled)
            repeatEnabled = try container.decode(Bool.self, forKey: .repeatEnabled)
            gaplessPlaybackEnabled = try container.decode(Bool.self, forKey: .gaplessPlaybackEnabled)
            volumeNormalizationEnabled = try container.decode(Bool.self, forKey: .volumeNormalizationEnabled)
            
            // Sweet Fades - use defaults for backward compatibility with older saved states
            sweetFadeEnabled = try container.decodeIfPresent(Bool.self, forKey: .sweetFadeEnabled) ?? false
            sweetFadeDuration = try container.decodeIfPresent(Double.self, forKey: .sweetFadeDuration) ?? 5.0
            
            // EQ settings
            eqEnabled = try container.decode(Bool.self, forKey: .eqEnabled)
            eqAutoEnabled = try container.decodeIfPresent(Bool.self, forKey: .eqAutoEnabled) ?? false
            eqPreamp = try container.decode(Float.self, forKey: .eqPreamp)
            eqBands = try container.decode([Float].self, forKey: .eqBands)
            
            // Playback state - try new format first, fall back to legacy
            if let tracks = try container.decodeIfPresent([SavedTrack].self, forKey: .playlistTracks) {
                playlistTracks = tracks
            } else if let urls = try container.decodeIfPresent([String].self, forKey: .playlistURLs) {
                // Convert legacy URLs to SavedTrack
                playlistTracks = urls.map { url in
                    SavedTrack(localURL: url, title: URL(string: url)?.lastPathComponent ?? "Unknown")
                }
            } else {
                playlistTracks = []
            }
            playlistURLs = nil  // Legacy field, not used anymore
            currentTrackIndex = try container.decode(Int.self, forKey: .currentTrackIndex)
            playbackPosition = try container.decode(Double.self, forKey: .playbackPosition)
            wasPlaying = try container.decode(Bool.self, forKey: .wasPlaying)
            
            // UI preferences
            timeDisplayMode = try container.decode(String.self, forKey: .timeDisplayMode)
            isAlwaysOnTop = try container.decode(Bool.self, forKey: .isAlwaysOnTop)
            
            // Skin
            customSkinPath = try container.decodeIfPresent(String.self, forKey: .customSkinPath)
            // baseSkinIndex from older saved states is silently ignored (base skins no longer bundled)
            
            // ProjectM preset - nil for backward compatibility with older saved states
            projectMPresetIndex = try container.decodeIfPresent(Int.self, forKey: .projectMPresetIndex)
            
            // v2 fields - all use decodeIfPresent for backward compatibility
            isDoubleSize = try container.decodeIfPresent(Bool.self, forKey: .isDoubleSize) ?? false
            modernSkinName = try container.decodeIfPresent(String.self, forKey: .modernSkinName)
            selectedOutputDeviceUID = try container.decodeIfPresent(String.self, forKey: .selectedOutputDeviceUID)
            browserBrowseMode = try container.decodeIfPresent(Int.self, forKey: .browserBrowseMode)
            savedInModernMode = try container.decodeIfPresent(Bool.self, forKey: .savedInModernMode) ?? false
            
            // Version
            stateVersion = try container.decodeIfPresent(Int.self, forKey: .stateVersion) ?? 1
        }
        
        // Standard memberwise initializer for saving state
        init(
            isPlaylistVisible: Bool,
            isEqualizerVisible: Bool,
            isPlexBrowserVisible: Bool,
            isProjectMVisible: Bool,
            isSpectrumVisible: Bool = false,
            mainWindowFrame: String?,
            playlistWindowFrame: String?,
            equalizerWindowFrame: String?,
            plexBrowserWindowFrame: String?,
            projectMWindowFrame: String?,
            spectrumWindowFrame: String? = nil,
            isProjectMFullscreen: Bool = false,
            volume: Float,
            balance: Float,
            shuffleEnabled: Bool,
            repeatEnabled: Bool,
            gaplessPlaybackEnabled: Bool,
            volumeNormalizationEnabled: Bool,
            sweetFadeEnabled: Bool,
            sweetFadeDuration: Double,
            eqEnabled: Bool,
            eqAutoEnabled: Bool,
            eqPreamp: Float,
            eqBands: [Float],
            playlistTracks: [SavedTrack],
            currentTrackIndex: Int,
            playbackPosition: Double,
            wasPlaying: Bool,
            timeDisplayMode: String,
            isAlwaysOnTop: Bool,
            customSkinPath: String? = nil,
            projectMPresetIndex: Int? = nil,
            isDoubleSize: Bool = false,
            modernSkinName: String? = nil,
            selectedOutputDeviceUID: String? = nil,
            browserBrowseMode: Int? = nil,
            savedInModernMode: Bool = false,
            stateVersion: Int = 2
        ) {
            self.isPlaylistVisible = isPlaylistVisible
            self.isEqualizerVisible = isEqualizerVisible
            self.isPlexBrowserVisible = isPlexBrowserVisible
            self.isProjectMVisible = isProjectMVisible
            self.isSpectrumVisible = isSpectrumVisible
            self.mainWindowFrame = mainWindowFrame
            self.playlistWindowFrame = playlistWindowFrame
            self.equalizerWindowFrame = equalizerWindowFrame
            self.plexBrowserWindowFrame = plexBrowserWindowFrame
            self.projectMWindowFrame = projectMWindowFrame
            self.spectrumWindowFrame = spectrumWindowFrame
            self.isProjectMFullscreen = isProjectMFullscreen
            self.volume = volume
            self.balance = balance
            self.shuffleEnabled = shuffleEnabled
            self.repeatEnabled = repeatEnabled
            self.gaplessPlaybackEnabled = gaplessPlaybackEnabled
            self.volumeNormalizationEnabled = volumeNormalizationEnabled
            self.sweetFadeEnabled = sweetFadeEnabled
            self.sweetFadeDuration = sweetFadeDuration
            self.eqEnabled = eqEnabled
            self.eqAutoEnabled = eqAutoEnabled
            self.eqPreamp = eqPreamp
            self.eqBands = eqBands
            self.playlistTracks = playlistTracks
            self.playlistURLs = nil  // Legacy, not used
            self.currentTrackIndex = currentTrackIndex
            self.playbackPosition = playbackPosition
            self.wasPlaying = wasPlaying
            self.timeDisplayMode = timeDisplayMode
            self.isAlwaysOnTop = isAlwaysOnTop
            self.customSkinPath = customSkinPath
            self.projectMPresetIndex = projectMPresetIndex
            self.isDoubleSize = isDoubleSize
            self.modernSkinName = modernSkinName
            self.selectedOutputDeviceUID = selectedOutputDeviceUID
            self.browserBrowseMode = browserBrowseMode
            self.savedInModernMode = savedInModernMode
            self.stateVersion = stateVersion
        }
    }
    
    // MARK: - Properties
    
    /// Whether the "Remember State" feature is enabled
    var isEnabled: Bool {
        get {
            UserDefaults.standard.bool(forKey: Keys.rememberStateEnabled)
        }
        set {
            UserDefaults.standard.set(newValue, forKey: Keys.rememberStateEnabled)
            NSLog("AppStateManager: Remember State %@", newValue ? "enabled" : "disabled")
        }
    }
    
    // MARK: - Initialization
    
    private init() {
        // Register default value (disabled by default)
        UserDefaults.standard.register(defaults: [
            Keys.rememberStateEnabled: false
        ])
    }
    
    // MARK: - Save State
    
    /// Save the current application state
    func saveState() {
        guard isEnabled else {
            NSLog("AppStateManager: Remember State disabled, skipping save")
            return
        }
        
        let wm = WindowManager.shared
        let engine = wm.audioEngine
        
        // Capture browser browse mode from the active browser window (if visible)
        var browserBrowseMode: Int? = nil
        if wm.isPlexBrowserVisible {
            browserBrowseMode = wm.plexBrowserBrowseMode
        }
        
        // Capture window visibility
        let state = AppState(
            // Window visibility
            isPlaylistVisible: wm.isPlaylistVisible,
            isEqualizerVisible: wm.isEqualizerVisible,
            isPlexBrowserVisible: wm.isPlexBrowserVisible,
            isProjectMVisible: wm.isProjectMVisible,
            isSpectrumVisible: wm.isSpectrumVisible,
            
            // Window frames
            mainWindowFrame: wm.mainWindowController?.window.map { NSStringFromRect($0.frame) },
            playlistWindowFrame: wm.playlistWindowController?.window.map { NSStringFromRect($0.frame) },
            equalizerWindowFrame: wm.equalizerWindowController?.window.map { NSStringFromRect($0.frame) },
            plexBrowserWindowFrame: wm.plexBrowserWindowFrame.map { NSStringFromRect($0) },
            // Don't save frame when fullscreen (it would be screen bounds)
            projectMWindowFrame: wm.isProjectMVisible && !wm.isProjectMFullscreen ? wm.projectMWindowFrame.map { NSStringFromRect($0) } : nil,
            spectrumWindowFrame: wm.spectrumWindowFrame.map { NSStringFromRect($0) },
            isProjectMFullscreen: wm.isProjectMFullscreen,
            
            // Audio settings
            volume: engine.volume,
            balance: engine.balance,
            shuffleEnabled: engine.shuffleEnabled,
            repeatEnabled: engine.repeatEnabled,
            gaplessPlaybackEnabled: engine.gaplessPlaybackEnabled,
            volumeNormalizationEnabled: engine.volumeNormalizationEnabled,
            
            // Sweet Fades settings
            sweetFadeEnabled: engine.sweetFadeEnabled,
            sweetFadeDuration: engine.sweetFadeDuration,
            
            // EQ settings
            eqEnabled: engine.isEQEnabled(),
            eqAutoEnabled: UserDefaults.standard.bool(forKey: "EQAutoEnabled"),
            eqPreamp: engine.getPreamp(),
            eqBands: (0..<10).map { engine.getEQBand($0) },
            
            // Playback state - save all tracks with metadata for restoration
            playlistTracks: engine.playlist.map { track in
                SavedTrack.from(track, plexServerId: PlexManager.shared.currentServer?.id)
            },
            currentTrackIndex: engine.currentIndex,
            playbackPosition: engine.currentTime,
            wasPlaying: engine.state == .playing,
            
            // UI preferences
            timeDisplayMode: wm.timeDisplayMode.rawValue,
            isAlwaysOnTop: wm.isAlwaysOnTop,
            
            // Skin - save path if using a custom skin
            customSkinPath: getCustomSkinPath(),
            
            // ProjectM preset
            projectMPresetIndex: wm.visualizationPresetIndex,
            
            // v2 fields
            isDoubleSize: wm.isDoubleSize,
            modernSkinName: UserDefaults.standard.string(forKey: "modernSkinName"),
            selectedOutputDeviceUID: UserDefaults.standard.string(forKey: "selectedOutputDeviceUID"),
            browserBrowseMode: browserBrowseMode,
            savedInModernMode: wm.isModernUIEnabled
        )
        
        // Encode and save
        do {
            let encoder = JSONEncoder()
            let data = try encoder.encode(state)
            UserDefaults.standard.set(data, forKey: Keys.savedAppState)
            NSLog("AppStateManager: Saved state - playlist: %d tracks, trackIndex: %d, position: %.1fs, volume: %.2f, doubleSize: %d",
                  state.playlistTracks.count, state.currentTrackIndex, state.playbackPosition, state.volume, state.isDoubleSize ? 1 : 0)
        } catch {
            NSLog("AppStateManager: Failed to save state: %@", error.localizedDescription)
        }
    }
    
    // MARK: - Restore State
    
    /// Restore the previously saved application state
    /// Call this after windows are created but before showing them
    /// - Returns: true if state was restored (has playlist), false otherwise
    @discardableResult
    func restoreState() -> Bool {
        guard isEnabled else {
            NSLog("AppStateManager: Remember State disabled, skipping restore")
            return false
        }
        
        guard let data = UserDefaults.standard.data(forKey: Keys.savedAppState) else {
            NSLog("AppStateManager: No saved state found")
            return false
        }
        
        do {
            let decoder = JSONDecoder()
            let state = try decoder.decode(AppState.self, from: data)
            let hasPlaylist = !state.playlistTracks.isEmpty
            applyState(state)
            return hasPlaylist
        } catch {
            NSLog("AppStateManager: Failed to restore state: %@", error.localizedDescription)
            return false
        }
    }
    
    /// Restore only settings state (skin, volume, EQ, windows)
    /// Called early in launch before playlist state is restored
    func restoreSettingsState() {
        guard isEnabled else {
            NSLog("AppStateManager: Remember State disabled, skipping settings restore")
            return
        }
        
        guard let data = UserDefaults.standard.data(forKey: Keys.savedAppState) else {
            NSLog("AppStateManager: No saved state found for settings restore")
            return
        }
        
        do {
            let decoder = JSONDecoder()
            let state = try decoder.decode(AppState.self, from: data)
            applySettingsState(state)
        } catch {
            NSLog("AppStateManager: Failed to restore settings state: %@", error.localizedDescription)
        }
    }
    
    /// Restore only playlist state (tracks, position, playback)
    func restorePlaylistState() {
        guard isEnabled else {
            NSLog("AppStateManager: Remember State disabled, skipping playlist restore")
            return
        }
        
        guard let data = UserDefaults.standard.data(forKey: Keys.savedAppState) else {
            NSLog("AppStateManager: No saved state found for playlist restore")
            return
        }
        
        do {
            let decoder = JSONDecoder()
            let state = try decoder.decode(AppState.self, from: data)
            applyPlaylistState(state)
        } catch {
            NSLog("AppStateManager: Failed to restore playlist state: %@", error.localizedDescription)
        }
    }
    
    /// Apply settings state (skin, volume, EQ, windows) - no playlist
    private func applySettingsState(_ state: AppState) {
        let wm = WindowManager.shared
        let engine = wm.audioEngine
        
        NSLog("AppStateManager: Restoring settings state - volume: %.2f", state.volume)
        
        // Restore audio settings
        engine.volume = state.volume
        engine.balance = state.balance
        engine.shuffleEnabled = state.shuffleEnabled
        engine.repeatEnabled = state.repeatEnabled
        engine.gaplessPlaybackEnabled = state.gaplessPlaybackEnabled
        engine.volumeNormalizationEnabled = state.volumeNormalizationEnabled
        
        // Restore Sweet Fades settings
        engine.sweetFadeEnabled = state.sweetFadeEnabled
        engine.sweetFadeDuration = state.sweetFadeDuration
        
        // Restore EQ settings
        engine.setEQEnabled(state.eqEnabled)
        UserDefaults.standard.set(state.eqAutoEnabled, forKey: "EQAutoEnabled")
        engine.setPreamp(state.eqPreamp)
        for (index, gain) in state.eqBands.enumerated() {
            engine.setEQBand(index, gain: gain)
        }
        
        // Restore UI preferences
        if let mode = TimeDisplayMode(rawValue: state.timeDisplayMode) {
            wm.timeDisplayMode = mode
        }
        NSLog("AppStateManager: Restoring isAlwaysOnTop = %d", state.isAlwaysOnTop ? 1 : 0)
        wm.isAlwaysOnTop = state.isAlwaysOnTop
        
        // Restore skin (custom skin path only; base skins no longer bundled)
        if let skinPath = state.customSkinPath {
            let skinURL = URL(fileURLWithPath: skinPath)
            if FileManager.default.fileExists(atPath: skinPath) {
                wm.loadSkin(from: skinURL)
            }
        }
        
        // Restore modern skin name (if saved and modern UI is active)
        if wm.isModernUIEnabled, let modernSkin = state.modernSkinName {
            UserDefaults.standard.set(modernSkin, forKey: "modernSkinName")
            // ModernSkinEngine.loadPreferredSkin() is called in AppDelegate before state restore,
            // but we set the UserDefaults value here so subsequent launches use it
        }
        
        // Restore audio output device
        if let deviceUID = state.selectedOutputDeviceUID {
            UserDefaults.standard.set(deviceUID, forKey: "selectedOutputDeviceUID")
        }
        
        // Check if the saved state's UI mode matches the current mode.
        // If mismatched (e.g. saved in modern, now running classic), skip window frame
        // restoration since the windows have different sizes and constraints.
        let modeMatches = state.savedInModernMode == wm.isModernUIEnabled
        if !modeMatches {
            NSLog("AppStateManager: UI mode changed (saved=%@, current=%@) - skipping window frame restoration",
                  state.savedInModernMode ? "modern" : "classic",
                  wm.isModernUIEnabled ? "modern" : "classic")
        }
        
        // Restore window frames (only if mode matches)
        if modeMatches {
            restoreWindowFrames(state)
        }
        
        // Restore window visibility (after a short delay to ensure proper positioning)
        // Parse frames before the closure to avoid capturing state
        // Only pass saved frames if the UI mode matches; otherwise use nil (default positions)
        let playlistFrame = modeMatches ? state.playlistWindowFrame.flatMap({ NSRectFromString($0) }) : nil
        let equalizerFrame = modeMatches ? state.equalizerWindowFrame.flatMap({ NSRectFromString($0) }) : nil
        let browserFrame = modeMatches ? state.plexBrowserWindowFrame.flatMap({ NSRectFromString($0) }) : nil
        let projectMFrame = modeMatches ? state.projectMWindowFrame.flatMap({ NSRectFromString($0) }) : nil
        let spectrumFrame = modeMatches ? state.spectrumWindowFrame.flatMap({ NSRectFromString($0) }) : nil
        let projectMPresetIndex = state.projectMPresetIndex
        let projectMFullscreen = state.isProjectMFullscreen
        let savedBrowseMode = state.browserBrowseMode
        let savedDoubleSize = state.isDoubleSize
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            if state.isEqualizerVisible {
                wm.showEqualizer(at: equalizerFrame)
            }
            if state.isPlaylistVisible {
                wm.showPlaylist(at: playlistFrame)
            }
            if state.isSpectrumVisible {
                wm.showSpectrum(at: spectrumFrame)
            }
            if state.isPlexBrowserVisible {
                wm.showPlexBrowser(at: browserFrame)
                
                // Restore browse mode after the browser window is shown and view is ready
                if let browseMode = savedBrowseMode {
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
                        wm.plexBrowserBrowseMode = browseMode
                        NSLog("AppStateManager: Restored browser browse mode: %d", browseMode)
                    }
                }
            }
            if state.isProjectMVisible {
                wm.showProjectM(at: projectMFrame)
                
                // Restore fullscreen state BEFORE preset
                if projectMFullscreen {
                    wm.toggleProjectMFullscreen()
                }
                
                // Restore ProjectM preset after engine is initialized on render thread
                // The engine setup is deferred and takes ~200ms to complete
                if let presetIndex = projectMPresetIndex {
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                        wm.selectVisualizationPreset(at: presetIndex)
                        NSLog("AppStateManager: Restored ProjectM preset index: %d", presetIndex)
                    }
                }
            }
            
            // Restore double size mode (modern UI only) after windows are positioned
            if savedDoubleSize && wm.isModernUIEnabled {
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
                    wm.isDoubleSize = true
                    NSLog("AppStateManager: Restored double size mode")
                }
            }
        }
        
        NSLog("AppStateManager: Settings state restored (eqAutoEnabled: %d, doubleSize: %d)", state.eqAutoEnabled ? 1 : 0, state.isDoubleSize ? 1 : 0)
    }
    
    /// Apply playlist state: populates the playlist preserving original order,
    /// selects the current track, and seeks to saved position.
    /// Streaming tracks start as placeholders (with saved metadata for display)
    /// and are replaced with real tracks as async fetches complete.
    private func applyPlaylistState(_ state: AppState) {
        let wm = WindowManager.shared
        let engine = wm.audioEngine
        
        guard !state.playlistTracks.isEmpty else {
            NSLog("AppStateManager: No playlist to restore")
            return
        }
        
        NSLog("AppStateManager: Restoring playlist state - %d tracks, trackIndex: %d, position: %.1fs",
              state.playlistTracks.count, state.currentTrackIndex, state.playbackPosition)
        
        // Build the complete track list in original order.
        // Local and radio tracks are fully resolved immediately.
        // Streaming tracks (Plex/Subsonic/Jellyfin) get placeholder Track objects
        // with saved metadata, which are replaced when async fetches complete.
        var allTracks: [Track] = []
        var plexIndicesToFetch: [(SavedTrack, Int)] = []
        var subsonicIndicesToFetch: [(SavedTrack, Int)] = []
        var jellyfinIndicesToFetch: [(SavedTrack, Int)] = []
        var skippedIndices: Set<Int> = []
        
        for (index, savedTrack) in state.playlistTracks.enumerated() {
            if savedTrack.isRadio, let urlString = savedTrack.radioURL, let url = URL(string: urlString) {
                // Radio track - create from saved URL and metadata
                let track = Track(
                    url: url,
                    title: savedTrack.radioStationName ?? savedTrack.title,
                    artist: savedTrack.artist,
                    album: savedTrack.album,
                    duration: savedTrack.duration
                )
                allTracks.append(track)
            } else if let urlString = savedTrack.localURL, let url = URL(string: urlString) {
                // Local file - verify it still exists
                if FileManager.default.fileExists(atPath: url.path) {
                    allTracks.append(Track(url: url))
                } else {
                    // File no longer exists - add a placeholder that will display but won't play
                    NSLog("AppStateManager: Local file missing, skipping: %@", savedTrack.title)
                    skippedIndices.insert(index)
                    continue
                }
            } else if savedTrack.isPlex {
                // Plex track - create placeholder with saved metadata
                // Use about:blank as placeholder URL; will be replaced by async fetch
                let placeholder = Track(
                    url: URL(string: "about:blank")!,
                    title: savedTrack.title,
                    artist: savedTrack.artist,
                    album: savedTrack.album,
                    duration: savedTrack.duration,
                    contentType: savedTrack.contentType
                )
                plexIndicesToFetch.append((savedTrack, allTracks.count))
                allTracks.append(placeholder)
            } else if savedTrack.isSubsonic {
                let placeholder = Track(
                    url: URL(string: "about:blank")!,
                    title: savedTrack.title,
                    artist: savedTrack.artist,
                    album: savedTrack.album,
                    duration: savedTrack.duration,
                    contentType: savedTrack.contentType
                )
                subsonicIndicesToFetch.append((savedTrack, allTracks.count))
                allTracks.append(placeholder)
            } else if savedTrack.isJellyfin {
                let placeholder = Track(
                    url: URL(string: "about:blank")!,
                    title: savedTrack.title,
                    artist: savedTrack.artist,
                    album: savedTrack.album,
                    duration: savedTrack.duration,
                    contentType: savedTrack.contentType
                )
                jellyfinIndicesToFetch.append((savedTrack, allTracks.count))
                allTracks.append(placeholder)
            } else {
                // Unknown type - skip
                skippedIndices.insert(index)
            }
        }
        
        // Set the full playlist at once, preserving original order
        engine.setPlaylistTracks(allTracks)
        NSLog("AppStateManager: Set playlist with %d tracks (%d skipped)", allTracks.count, skippedIndices.count)
        
        // Adjust current track index to account for any skipped tracks
        var adjustedIndex = state.currentTrackIndex
        if !skippedIndices.isEmpty {
            // Count how many tracks before the saved index were skipped
            let skippedBefore = skippedIndices.filter { $0 < state.currentTrackIndex }.count
            adjustedIndex -= skippedBefore
        }
        
        // Select the current track (load it without playing)
        if adjustedIndex >= 0 && adjustedIndex < allTracks.count {
            // Use playTrack to load the track, then immediately pause
            engine.playTrack(at: adjustedIndex)
            engine.pause()
            
            // Seek to saved position after a brief delay to let the track load
            let savedPosition = state.playbackPosition
            if savedPosition > 0 {
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                    engine.seek(to: savedPosition)
                    NSLog("AppStateManager: Seeked to saved position: %.1fs", savedPosition)
                }
            }
            NSLog("AppStateManager: Selected track at index %d", adjustedIndex)
        }
        
        // Fetch streaming tracks asynchronously and replace placeholders
        let hasStreamingTracks = !plexIndicesToFetch.isEmpty || !subsonicIndicesToFetch.isEmpty || !jellyfinIndicesToFetch.isEmpty
        if hasStreamingTracks {
            let savedCurrentIndex = adjustedIndex
            Task {
                var replacements: [(Track, Int)] = []  // (realTrack, playlistIndex)
                
                // Fetch Plex tracks
                if !plexIndicesToFetch.isEmpty, let client = PlexManager.shared.serverClient {
                    for (savedTrack, playlistIndex) in plexIndicesToFetch {
                        if let ratingKey = savedTrack.plexRatingKey {
                            do {
                                if let plexTrack = try await client.fetchTrackDetails(trackID: ratingKey),
                                   let track = PlexManager.shared.convertToTrack(plexTrack) {
                                    replacements.append((track, playlistIndex))
                                }
                            } catch {
                                NSLog("AppStateManager: Failed to fetch Plex track %@: %@",
                                      savedTrack.title, error.localizedDescription)
                            }
                        }
                    }
                }
                
                // Fetch Subsonic tracks
                for (savedTrack, playlistIndex) in subsonicIndicesToFetch {
                    if let songId = savedTrack.subsonicId,
                       let serverId = savedTrack.subsonicServerId,
                       SubsonicManager.shared.servers.contains(where: { $0.id == serverId }),
                       let credentials = KeychainHelper.shared.getSubsonicServer(id: serverId),
                       let client = SubsonicServerClient(credentials: credentials) {
                        do {
                            if let song = try await client.fetchSong(id: songId),
                               let track = SubsonicManager.shared.convertToTrack(song) {
                                replacements.append((track, playlistIndex))
                            }
                        } catch {
                            NSLog("AppStateManager: Failed to fetch Subsonic track %@: %@",
                                  savedTrack.title, error.localizedDescription)
                        }
                    }
                }
                
                // Fetch Jellyfin tracks
                for (savedTrack, playlistIndex) in jellyfinIndicesToFetch {
                    if let jellyfinId = savedTrack.jellyfinId,
                       let serverId = savedTrack.jellyfinServerId,
                       JellyfinManager.shared.servers.contains(where: { $0.id == serverId }),
                       let credentials = KeychainHelper.shared.getJellyfinServer(id: serverId),
                       let client = JellyfinServerClient(credentials: credentials) {
                        do {
                            if let song = try await client.fetchSong(id: jellyfinId),
                               let track = JellyfinManager.shared.convertToTrack(song) {
                                replacements.append((track, playlistIndex))
                            }
                        } catch {
                            NSLog("AppStateManager: Failed to fetch Jellyfin track %@: %@",
                                  savedTrack.title, error.localizedDescription)
                        }
                    }
                }
                
                // Replace placeholder tracks with real ones on the main thread
                await MainActor.run {
                    var replacedCurrentTrack = false
                    for (realTrack, playlistIndex) in replacements {
                        engine.replaceTrack(at: playlistIndex, with: realTrack)
                        if playlistIndex == savedCurrentIndex {
                            replacedCurrentTrack = true
                        }
                    }
                    NSLog("AppStateManager: Replaced %d streaming track placeholders", replacements.count)
                    
                    // If the current track was a streaming placeholder, reload it
                    // now that we have the real URL
                    if replacedCurrentTrack && savedCurrentIndex >= 0 {
                        let savedPosition = state.playbackPosition
                        engine.playTrack(at: savedCurrentIndex)
                        engine.pause()
                        if savedPosition > 0 {
                            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                                engine.seek(to: savedPosition)
                            }
                        }
                    }
                }
            }
        }
        
        NSLog("AppStateManager: Playlist state restoration initiated")
    }
    
    /// Apply the restored state to the app (full restore - used by restoreState())
    private func applyState(_ state: AppState) {
        // Apply settings first (skin, volume, EQ, windows, v2 fields)
        applySettingsState(state)
        
        // Then apply playlist state (tracks, position, current track)
        if !state.playlistTracks.isEmpty {
            applyPlaylistState(state)
        }
        
        NSLog("AppStateManager: State restored successfully")
    }
    
    /// Restore window frames from saved state
    /// Note: Only the main window frame is restored here since it exists at restore time.
    /// Playlist, EQ, Browser, and ProjectM frames are passed to their show methods
    /// in applyState() since those windows are created lazily.
    private func restoreWindowFrames(_ state: AppState) {
        let wm = WindowManager.shared
        
        // Main window exists at this point, so we can restore its frame directly
        if let frameString = state.mainWindowFrame,
           let window = wm.mainWindowController?.window {
            let frame = NSRectFromString(frameString)
            if frame != .zero {
                window.setFrame(frame, display: true)
            }
        }
        
        // Note: Playlist, EQ, Browser, and ProjectM frames are passed directly to their
        // show methods in applyState() since those windows are created lazily and don't
        // exist yet when this function is called.
    }
    
    // MARK: - Helpers
    
    /// Get the custom skin path if a non-default skin is loaded
    private func getCustomSkinPath() -> String? {
        // Return the currently loaded custom skin path tracked by WindowManager
        return WindowManager.shared.currentSkinPath
    }
    
    // MARK: - Clear State
    
    /// Clear the saved state
    func clearSavedState() {
        UserDefaults.standard.removeObject(forKey: Keys.savedAppState)
        NSLog("AppStateManager: Cleared saved state")
    }
}
